import sys
N,K = map(int,sys.stdin.readline().split())

dp = [[0 for _ in range(N+1)] for _ in range(N+1)]

for i in range(N+1):
    dp[1][i] = 1
    dp[2][i] = i+1
for i in range(3,N+1):
    dp[i][1]=i
    for j in range(2,N+1):
        dp[i][j] = dp[i-1][j]+dp[i][j-1]
print(dp[K][N]%1000000000)

'''
위 코드는 Baekjoon에서 "런타임 에러"를 발생시킨다.
[1] 배열 인덱스 범위 초과

코드에서 dp 배열은 N+1 x N+1 크기로 선언되어 있습니다. 
그러나 for 루프에서 dp[1][i], dp[2][i]에 접근하고 있는데, 
이러한 인덱스가 유효한지 확인할 필요가 있습니다.
만약 N이 매우 큰 값이라면, 
이로 인해 메모리 문제 또는 배열 인덱스 초과 문제가 발생할 수 있습니다. 
특히 dp[2][i] = i+1에서 i가 N까지 범위로 가면, 
dp 배열의 인덱스 범위를 초과할 수 있습니다.

[2] dp 배열의 초기화

코드에서 dp[1][i]와 dp[2][i]를 초기화하는데, 
dp[1][i]와 dp[2][i]는 배열의 인덱스 범위를 초과할 수 있습니다.
dp[1][i]와 dp[2][i]를 초기화하기 위해서는 i가 1부터 N까지의 범위가 아니라 0부터 N까지의 범위를 벗어나지 않아야 합니다.

[3] print(dp[K][N]%1000000000)

출력할 때 K와 N의 값이 dp 배열의 유효한 인덱스 범위 내에 있어야 합니다. 
만약 K가 N보다 크거나 작은 경우 dp[K][N]에 접근할 수 없으므로 
런타임 에러가 발생할 수 있습니다.

-------------------- 다음과 같이 수정할 수 있다. ------------------
# DP 배열을 K+1 x N+1 크기로 설정
dp = [[0] * (N + 1) for _ in range(K + 1)]

# 초기화
for i in range(N + 1):
    dp[1][i] = 1  # K가 1일 때, 각 i에 대한 경우의 수는 1가지

for i in range(2, K + 1):
    dp[i][0] = 1  # N이 0일 때, 경우의 수는 1가지
    for j in range(1, N + 1):
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]

# 결과 출력
print(dp[K][N] % 1000000000)

'''